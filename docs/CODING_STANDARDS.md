# ä»£ç è§„èŒƒ

## ğŸ“‘ ç›®å½•

-   [æ ¸å¿ƒåŸåˆ™](#æ ¸å¿ƒåŸåˆ™)
    -   [ä¸­æ–‡ä¼˜å…ˆåŸåˆ™](#ä¸­æ–‡ä¼˜å…ˆåŸåˆ™)
    -   [ä»£ç å³æ–‡æ¡£åŸåˆ™](#ä»£ç å³æ–‡æ¡£åŸåˆ™)
    -   [é¡¹ç›®æŠ€æœ¯æ ˆçº¦æŸåŸåˆ™](#ä»£ç å³æ–‡æ¡£åŸåˆ™)
    -   [æµ‹è¯•è¦æ±‚åŸåˆ™](#æµ‹è¯•è¦æ±‚åŸåˆ™)
-   [å¯¼å…¥é¡ºåºå’Œé£æ ¼](#å¯¼å…¥é¡ºåºå’Œé£æ ¼)
-   [æ ¼å¼åŒ–è§„åˆ™](#æ ¼å¼åŒ–è§„åˆ™)
-   [TypeScript ç±»å‹å®šä¹‰](#typescript-ç±»å‹å®šä¹‰)
    -   [ç±»å‹å®šä¹‰](#ç±»å‹å®šä¹‰)
    -   [æ³›å‹ç±»å‹](#æ³›å‹ç±»å‹)
-   [æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ](#æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ)
    -   [TSDoc æ³¨é‡Šè§„èŒƒ](#tsdoc-æ³¨é‡Šè§„èŒƒ)
    -   [TSDoc æ ‡ç­¾è¯´æ˜](#tsdoc-æ ‡ç­¾è¯´æ˜)
    -   [ä¸šåŠ¡è¯­ä¹‰æ³¨é‡Šè§„èŒƒ](#ä¸šåŠ¡è¯­ä¹‰æ³¨é‡Šè§„èŒƒ)
-   [å‘½åè§„èŒƒ](#å‘½åè§„èŒƒ)
    -   [æ–‡ä»¶å‘½å](#æ–‡ä»¶å‘½å)
    -   [ç±»å‘½å](#ç±»å‘½å)
    -   [åŒ…å‘½å](#åŒ…å‘½å)
-   [é”™è¯¯å¤„ç†](#é”™è¯¯å¤„ç†)
    -   [ä½¿ç”¨ NestJS å¼‚å¸¸](#ä½¿ç”¨-nestjs-å¼‚å¸¸)
    -   [é”™è¯¯æ¶ˆæ¯è§„èŒƒ](#é”™è¯¯æ¶ˆæ¯è§„èŒƒ)
-   [ä¾èµ–æ³¨å…¥](#ä¾èµ–æ³¨å…¥)
-   [æœåŠ¡å±‚æ¨¡å¼](#æœåŠ¡å±‚æ¨¡å¼)
    -   [ä»“å‚¨æ¨¡å¼](#ä»“å‚¨æ¨¡å¼)
    -   [EntityManager è®¿é—®](#entitymanager-è®¿é—®)
-   [æ§åˆ¶å™¨å±‚æ¨¡å¼](#æ§åˆ¶å™¨å±‚æ¨¡å¼)
    -   [è£…é¥°å™¨é¡ºåº](#è£…é¥°å™¨é¡ºåº)
    -   [å“åº”æ ¼å¼](#å“åº”æ ¼å¼)
-   [å®ä½“å®šä¹‰](#å®ä½“å®šä¹‰)
    -   [å®ä½“ç»“æ„](#å®ä½“ç»“æ„)
    -   [å®ä½“å­—æ®µç±»å‹](#å®ä½“å­—æ®µç±»å‹)
-   [æ¨¡å—å®šä¹‰](#æ¨¡å—å®šä¹‰)
-   [æµ‹è¯•è§„èŒƒ](#æµ‹è¯•è§„èŒƒ)
    -   [æµ‹è¯•æ–‡ä»¶ä½ç½®](#æµ‹è¯•æ–‡ä»¶ä½ç½®)
    -   [æµ‹è¯•è¦†ç›–ç‡è¦æ±‚](#æµ‹è¯•è¦†ç›–ç‡è¦æ±‚)
    -   [æµ‹è¯•æ–‡ä»¶ç¤ºä¾‹](#æµ‹è¯•æ–‡ä»¶ç¤ºä¾‹)
-   [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ ¸å¿ƒåŸåˆ™

### ä¸­æ–‡ä¼˜å…ˆåŸåˆ™

**é€‚ç”¨èŒƒå›´ï¼š** æ‰€æœ‰ä»£ç æ³¨é‡Šã€æŠ€æœ¯æ–‡æ¡£ã€é”™è¯¯æ¶ˆæ¯ã€æ—¥å¿—è¾“å‡ºåŠç”¨æˆ·ç•Œé¢æ–‡æ¡ˆ

**å…·ä½“è¦æ±‚ï¼š**

-   æ‰€æœ‰ä»£ç æ³¨é‡Šå¿…é¡»ä½¿ç”¨ä¸­æ–‡
-   æ‰€æœ‰æŠ€æœ¯æ–‡æ¡£å¿…é¡»ä½¿ç”¨ä¸­æ–‡
-   æ‰€æœ‰é”™è¯¯æ¶ˆæ¯å¿…é¡»ä½¿ç”¨ä¸­æ–‡
-   æ‰€æœ‰æ—¥å¿—è¾“å‡ºå¿…é¡»ä½¿ç”¨ä¸­æ–‡
-   æ‰€æœ‰ç”¨æˆ·ç•Œé¢æ–‡æ¡ˆå¿…é¡»ä½¿ç”¨ä¸­æ–‡
-   Git æäº¤ä¿¡æ¯å¿…é¡»ä½¿ç”¨è‹±æ–‡æè¿°
-   ä»£ç å˜é‡å‘½åä¿æŒè‹±æ–‡ï¼Œä½†å¿…é¡»é…æœ‰ä¸­æ–‡æ³¨é‡Šè¯´æ˜ä¸šåŠ¡è¯­ä¹‰

**ç†ç”±ï¼š** ç»Ÿä¸€ä¸­æ–‡è¯­å¢ƒæå‡å›¢é˜Ÿæ²Ÿé€šæ•ˆç‡ï¼Œç¡®ä¿ä¸šåŠ¡è®¤çŸ¥ä¸€è‡´ï¼Œé™ä½çŸ¥è¯†ä¼ é€’æˆæœ¬ã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - ä¸­æ–‡æ³¨é‡Šå’Œé”™è¯¯æ¶ˆæ¯
async createTenant(data: CreateTenantDto): Promise<Tenant> {
    // æ£€æŸ¥ç§Ÿæˆ·æ ‡è¯†æ˜¯å¦å·²å­˜åœ¨
    const existing = await this.tenantRepo.findOne({ slug: data.slug });
    if (existing) {
        throw new BadRequestException('ç§Ÿæˆ·æ ‡è¯†å·²å­˜åœ¨');
    }
    // åˆ›å»ºæ–°ç§Ÿæˆ·å¹¶è®¾ç½®é»˜è®¤çŠ¶æ€
    const tenant = this.tenantRepo.create({
        ...data,
        status: TenantStatus.ACTIVE,
        type: TenantType.ORGANIZATION
    });
    await this.em.persistAndFlush(tenant);
    return tenant;
}

// âŒ é”™è¯¯ - è‹±æ–‡æ³¨é‡Šå’Œé”™è¯¯æ¶ˆæ¯
async createTenant(data: CreateTenantDto): Promise<Tenant> {
    const existing = await this.tenantRepo.findOne({ slug: data.slug });
    if (existing) {
        throw new BadRequestException('Tenant slug already exists');
    }
    const tenant = this.tenantRepo.create({ ...data });
    await this.em.persistAndFlush(tenant);
    return tenant;
}
```

---

### ä»£ç å³æ–‡æ¡£åŸåˆ™

**é€‚ç”¨èŒƒå›´ï¼š** å…¬å…± APIã€ç±»ã€æ–¹æ³•ã€æ¥å£ã€æšä¸¾

**å…·ä½“è¦æ±‚ï¼š**

-   å…¬å…± APIã€ç±»ã€æ–¹æ³•ã€æ¥å£ã€æšä¸¾å¿…é¡»ç¼–å†™å®Œæ•´ TSDoc æ³¨é‡Š
-   TSDoc å¿…é¡»è¦†ç›–ï¼šåŠŸèƒ½æè¿°ã€ä¸šåŠ¡è§„åˆ™ã€ä½¿ç”¨åœºæ™¯ã€å‰ç½®æ¡ä»¶ã€åç½®æ¡ä»¶ã€å¼‚å¸¸æŠ›å‡ºåŠæ³¨æ„äº‹é¡¹
-   ä»£ç å˜æ›´æ—¶å¿…é¡»åŒæ­¥æ›´æ–°æ³¨é‡Šï¼Œä¿æŒå®ç°ä¸æ–‡æ¡£ä¸€è‡´

**ç†ç”±ï¼š** é€šè¿‡é«˜è´¨é‡æ³¨é‡Šè®©ä»£ç è‡ªèº«æˆä¸ºæƒå¨ä¸šåŠ¡æ–‡æ¡£ï¼Œç¼©çŸ­äº¤æ¥æ—¶é—´å¹¶å‡å°‘é¢å¤–æ–‡æ¡£ç»´æŠ¤è´Ÿæ‹…ã€‚

---

### é¡¹ç›®æŠ€æœ¯æ ˆçº¦æŸåŸåˆ™

**å…·ä½“è¦æ±‚ï¼š**

-   å…¨ä»“ç»Ÿä¸€é‡‡ç”¨ Node.js + TypeScript
-   ä½¿ç”¨ pnpm ç®¡ç†ä¾èµ–å¹¶é€šè¿‡ monorepo ç»„ç»‡ä»£ç 

---

### æµ‹è¯•è¦æ±‚åŸåˆ™

**å…·ä½“è¦æ±‚ï¼š**

-   å•å…ƒæµ‹è¯•ä¸è¢«æµ‹æ–‡ä»¶åŒç›®å½•ï¼ˆæ—æ”¾ï¼‰ï¼Œå‘½åæ ¼å¼ `{filename}.spec.ts`
-   é›†æˆä¸ç«¯åˆ°ç«¯æµ‹è¯•é›†ä¸­æ”¾ç½®åœ¨ `tests/integration/` ä¸ `tests/e2e/`
-   é‡‡ç”¨åˆ†å±‚æµ‹è¯•ç­–ç•¥ï¼šå•å…ƒã€é›†æˆã€ç«¯åˆ°ç«¯å„å¸å…¶èŒï¼Œç¡®ä¿å¿«é€Ÿåé¦ˆä¸å¯ç»´æŠ¤æ€§
-   æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•è¦†ç›–ç‡é¡»è¾¾åˆ° 80% ä»¥ä¸Š
-   å…³é”®è·¯å¾„æµ‹è¯•è¦†ç›–ç‡é¡»è¾¾åˆ° 90% ä»¥ä¸Š
-   æ‰€æœ‰å…¬å…± API å¿…é¡»å…·å¤‡æµ‹è¯•ç”¨ä¾‹

**ç†ç”±ï¼š** é«˜æ ‡å‡†æµ‹è¯•ä½“ç³»ä¿éšœå…³é”®åŠŸèƒ½å¯é æ€§ï¼Œæ”¯æŒå¿«é€Ÿè¿­ä»£å¹¶é˜²æ­¢å›å½’ã€‚

---

## å¯¼å…¥é¡ºåºå’Œé£æ ¼

å¯¼å…¥åº”æŒ‰ä»¥ä¸‹ç‰¹å®šé¡ºåºæ’åˆ—ï¼š

1. **Node.js å†…ç½®æ¨¡å—**ï¼ˆpathã€crypto ç­‰ï¼‰
2. **@nestjs/common** - è£…é¥°å™¨å’Œå¼‚å¸¸
3. **@nestjs/core** - æ ¸å¿ƒ NestJS åŠŸèƒ½
4. **@nestjs/xxx** - å…¶ä»– NestJS æ¨¡å—ï¼ˆconfigã€platform-express ç­‰ï¼‰
5. **@mikro-orm/xxx** - MikroORM å¯¼å…¥
6. **å†…éƒ¨åŒ…å¯¼å…¥**ï¼ˆ@oksai/\*ï¼‰
7. **æœ¬åœ°å¯¼å…¥**ï¼ˆç›¸å¯¹è·¯å¾„å¯¼å…¥ï¼‰
8. **ä»…ç±»å‹å¯¼å…¥**ï¼ˆtype-only importsï¼Œå¦‚æœéœ€è¦ï¼‰

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
import { randomUUID } from 'crypto';
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@mikro-orm/nestjs';
import { EntityRepository, wrap } from '@mikro-orm/core';
import { JwtPayload } from '@oksai/core';
import { LoginDto } from './dto';
import type { IUserRepository } from './interfaces';

// âŒ é”™è¯¯
import { Injectable, InjectRepository } from '@nestjs/common';
import { EntityRepository } from '@mikro-orm/core';
import { randomUUID } from 'crypto';
```

---

## æ ¼å¼åŒ–è§„åˆ™

ä½¿ç”¨ Prettier é…ç½®çš„è®¾ç½®ï¼ˆåœ¨ `.prettierrc` ä¸­é…ç½®ï¼‰ï¼š

-   **æ‰“å°å®½åº¦ï¼š** 120
-   **å•å¼•å·ï¼š** true
-   **åˆ†å·ï¼š** true
-   **ä½¿ç”¨ Tab ç¼©è¿›ï¼ˆtab å®½åº¦ï¼š4ï¼‰**
-   **æ— å°¾éšé€—å·**
-   **å¼•å·å±æ€§ï¼š** æŒ‰éœ€ä½¿ç”¨

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
@Injectable()
export class AuthService {
	constructor(
		@InjectRepository(User)
		private readonly userRepo: EntityRepository<User>
	) {}
}

// âŒ é”™è¯¯ï¼ˆå°¾éšé€—å·ï¼‰
@Injectable()
export class AuthService {
	constructor(
		@InjectRepository(User),
		private readonly userRepo: EntityRepository<User>,
	) {}
}
```

---

## TypeScript ç±»å‹å®šä¹‰

### ç±»å‹å®šä¹‰

-   ä½¿ç”¨æ¥å£è¡¨ç¤ºå…¬å…±å¥‘çº¦
-   ä½¿ç”¨ç±»è¡¨ç¤ºå®ç°
-   ä½¿ç”¨ç±»å‹åˆ«åè¡¨ç¤ºå¤æ‚ç±»å‹
-   å§‹ç»ˆä½¿ç”¨ä¸¥æ ¼ç±»å‹ï¼ˆé¿å…ä½¿ç”¨ `any`ï¼‰

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - DTO æ¥å£
export interface CreateUserDto {
	email: string;
	password: string;
	firstName: string;
	lastName: string;
}

// âœ… æ­£ç¡® - ç±»å‹åˆ«å
export type UserId = string;

// âŒ é”™è¯¯ - ä½¿ç”¨ any
async findUser(id: any): Promise<any> {
	return await this.userRepo.findOne({ id });
}

// âœ… æ­£ç¡® - æ­£ç¡®çš„ç±»å‹
async findUser(id: string): Promise<User | null> {
	return await this.userRepo.findOne({ id });
}
```

### æ³›å‹ç±»å‹

-   ä½¿ç”¨ `T` è¡¨ç¤ºæ³›å‹ç±»å‹å‚æ•°
-   ä½¿ç”¨ `K` è¡¨ç¤ºé”®ç±»å‹
-   ä½¿ç”¨ `V` è¡¨ç¤ºå€¼ç±»å‹

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
interface Repository<T> {
	findOne(id: string): Promise<T | null>;
	findMany(filter: Filter<T>): Promise<T[]>;
}

// âŒ é”™è¯¯
interface Repository {
	findOne(id: string): Promise<any>;
}
```

---

## æ³¨é‡Šå’Œæ–‡æ¡£è§„èŒƒ

### TSDoc æ³¨é‡Šè§„èŒƒ

å…¬å…± APIã€ç±»ã€æ–¹æ³•ã€æ¥å£ã€æšä¸¾å¿…é¡»ç¼–å†™å®Œæ•´ TSDoc æ³¨é‡Šã€‚

**ç¤ºä¾‹ï¼š**

````typescript
/**
 * è®¤è¯æœåŠ¡
 *
 * æä¾›ç”¨æˆ·è®¤è¯ã€JWT ä»¤ç‰Œç®¡ç†ã€å¯†ç é‡ç½®ç­‰åŠŸèƒ½
 */
@Injectable()
export class AuthService {
	/**
	 * ç”¨æˆ·ç™»å½•
	 *
	 * éªŒè¯ç”¨æˆ·å‡­è¯å¹¶ç”Ÿæˆ JWT è®¿é—®ä»¤ç‰Œå’Œåˆ·æ–°ä»¤ç‰Œ
	 *
	 * @param credentials - ç™»å½•å‡­è¯ï¼ˆé‚®ç®±å’Œå¯†ç ï¼‰
	 * @returns åŒ…å«è®¿é—®ä»¤ç‰Œã€åˆ·æ–°ä»¤ç‰Œå’Œç”¨æˆ·ä¿¡æ¯çš„å“åº”
	 * @throws UnauthorizedException å½“å‡­è¯æ— æ•ˆæ—¶
	 * @throws BadRequestException å½“å¯†ç é”™è¯¯æ—¶
	 *
	 * @example
	 * ```typescript
	 * const result = await authService.login({
	 *   email: 'user@example.com',
	 *   password: 'password123'
	 * });
	 * ```
	 */
	async login(credentials: LoginDto): Promise<LoginResponse> {
		// å®ç°...
	}

	/**
	 * æ ¹æ®é‚®ç®±æŸ¥æ‰¾ç”¨æˆ·
	 *
	 * @param email - ç”¨æˆ·é‚®ç®±åœ°å€
	 * @returns ç”¨æˆ·å®ä½“ï¼ˆå¦‚æœæ‰¾åˆ°ï¼‰ï¼Œå¦åˆ™è¿”å› null
	 */
	async findByEmail(email: string): Promise<User | null> {
		return await this.userRepo.findOne({ email });
	}
}

// âŒ é”™è¯¯ - ç¼ºå°‘ TSDoc
@Injectable()
export class AuthService {
	async login(credentials: LoginDto): Promise<LoginResponse> {
		return await this.userRepo.findOne({ email: credentials.email });
	}
}
````

### TSDoc æ ‡ç­¾è¯´æ˜

-   `@param` - å‚æ•°è¯´æ˜ï¼ˆå¿…é¡»åŒ…å«ï¼‰
-   `@returns` - è¿”å›å€¼è¯´æ˜ï¼ˆå¿…é¡»åŒ…å«ï¼‰
-   `@throws` - æŠ›å‡ºçš„å¼‚å¸¸ï¼ˆå¦‚æœ‰ï¼‰
-   `@example` - ä½¿ç”¨ç¤ºä¾‹ï¼ˆæ¨èæ·»åŠ ï¼‰
-   `@see` - ç›¸å…³æ–‡æ¡£é“¾æ¥ï¼ˆå¦‚æœ‰ï¼‰

### ä¸šåŠ¡è¯­ä¹‰æ³¨é‡Šè§„èŒƒ

æ‰€æœ‰ä»£ç å˜é‡å’Œä¸šåŠ¡é€»è¾‘å¿…é¡»é…å¤‡ä¸­æ–‡æ³¨é‡Šè¯´æ˜ã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - é…å¤‡ä¸­æ–‡ä¸šåŠ¡è¯­ä¹‰æ³¨é‡Š
async createTenant(data: CreateTenantDto): Promise<Tenant> {
	// æ£€æŸ¥ç§Ÿæˆ·æ ‡è¯†æ˜¯å¦å·²å­˜åœ¨
	const existing = await this.tenantRepo.findOne({ slug: data.slug });
	if (existing) {
		throw new BadRequestException('ç§Ÿæˆ·æ ‡è¯†å·²å­˜åœ¨');
	}

	// åˆ›å»ºæ–°ç§Ÿæˆ·å¹¶è®¾ç½®é»˜è®¤çŠ¶æ€
	const tenant = this.tenantRepo.create({
		...data,
		status: TenantStatus.ACTIVE,
		type: TenantType.ORGANIZATION
	});

	await this.em.persistAndFlush(tenant);
	return tenant;
}

// âŒ é”™è¯¯ - ç¼ºå°‘ä¸­æ–‡æ³¨é‡Š
async createTenant(data: CreateTenantDto): Promise<Tenant> {
	const existing = await this.tenantRepo.findOne({ slug: data.slug });
	if (existing) {
		throw new BadRequestException('Tenant slug already exists');
	}

	const tenant = this.tenantRepo.create({ ...data });
	await this.em.persistAndFlush(tenant);
	return tenant;
}
```

---

## å‘½åè§„èŒƒ

### æ–‡ä»¶å‘½å

-   `kebab-case.ts` - æ™®é€šæ–‡ä»¶
-   `kebab-case.spec.ts` - æµ‹è¯•æ–‡ä»¶ï¼ˆä¸è¢«æµ‹æ–‡ä»¶åŒç›®å½•ï¼‰
-   `kebab-case.dto.ts` - DTO æ–‡ä»¶
-   `kebab-case.entity.ts` - å®ä½“æ–‡ä»¶
-   `kebab-case.service.ts` - æœåŠ¡æ–‡ä»¶
-   `kebab-case.controller.ts` - æ§åˆ¶å™¨æ–‡ä»¶
-   `kebab-case.module.ts` - æ¨¡å—æ–‡ä»¶

### ç±»å‘½å

-   `PascalCase` - ç”¨äºç±»ã€æ¥å£ã€ç±»å‹
-   `camelCase` - ç”¨äºå‡½æ•°ã€å˜é‡ã€å±æ€§
-   `UPPER_SNAKE_CASE` - ç”¨äºå¸¸é‡

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
export class AuthService {
	private readonly userRepo: EntityRepository<User>;
	private static readonly MAX_RETRY_COUNT = 3;
	async login(): Promise<LoginResponse> {}
}

// âŒ é”™è¯¯
export class authService {
	private readonly userRepo: EntityRepository<User>;
	private static readonly max_retry_count = 3;
	async Login(): Promise<login_response> {}
}
```

### åŒ…å‘½å

-   ä½¿ç”¨ `@oksai/kebab-case` è¡¨ç¤ºåŒ…å
-   åŒ…åå¿…é¡»å°å†™

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
import { JwtPayload } from '@oksai/core';
import { AuthService } from '@oksai/auth';
import { TenantService } from '@oksai/tenant';

// âŒ é”™è¯¯
import { JwtPayload } from '@oksai/Core';
import { AuthService } from '@oksai/Auth';
```

---

## é”™è¯¯å¤„ç†

### ä½¿ç”¨ NestJS å¼‚å¸¸

å§‹ç»ˆä½¿ç”¨ `@nestjs/common` ä¸­çš„ NestJS å†…ç½®å¼‚å¸¸ï¼š

-   `NotFoundException` - 404 Not Found
-   `BadRequestException` - 400 Bad Request
-   `UnauthorizedException` - 401 Unauthorized
-   `ForbiddenException` - 403 Forbidden
-   `ConflictException` - 409 Conflict
-   `InternalServerErrorException` - 500 Internal Server Error

### é”™è¯¯æ¶ˆæ¯è§„èŒƒ

**é‡è¦ï¼š** é”™è¯¯æ¶ˆæ¯å¿…é¡»ä½¿ç”¨ä¸­æ–‡ï¼Œå¹¶éµå¾ªä»¥ä¸‹è§„èŒƒï¼š

-   ä½¿ç”¨æ¸…æ™°ã€ç”¨æˆ·å‹å¥½çš„ä¸­æ–‡é”™è¯¯æ¶ˆæ¯
-   åŒ…å«ç›¸å…³è¯¦ç»†ä¿¡æ¯ï¼ˆidã€emailã€slug ç­‰ï¼‰
-   é¦–å­—æ¯å¤§å†™ã€å¥æœ«åŠ æ ‡ç‚¹

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - ä¸­æ–‡é”™è¯¯æ¶ˆæ¯
async findById(id: string): Promise<User> {
	const user = await this.userRepo.findOne({ id });
	if (!user) {
		throw new NotFoundException(`æœªæ‰¾åˆ° ID ä¸º ${id} çš„ç”¨æˆ·`);
	}
	return user;
}

async createByEmail(email: string): Promise<User> {
	const existing = await this.userRepo.findOne({ email });
	if (existing) {
		throw new BadRequestException('æ­¤é‚®ç®±å·²è¢«ä½¿ç”¨');
	}
	return this.userRepo.create({ email, ...data });
}

// âŒ é”™è¯¯ - è‹±æ–‡é”™è¯¯æ¶ˆæ¯
async findById(id: string): Promise<User> {
	const user = await this.userRepo.findOne({ id });
	if (!user) {
		throw new NotFoundException('User not found');
	}
	return user;
}
```

---

## ä¾èµ–æ³¨å…¥

ä½¿ç”¨æ„é€ å‡½æ•°æ³¨å…¥å¹¶é…åˆ `readonly` ä¿®é¥°ç¬¦ã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
@Injectable()
export class AuthService {
	constructor(
		@InjectRepository(User)
		private readonly userRepo: EntityRepository<User>,
		private readonly jwtService: JwtService
	) {}
}

// âŒ é”™è¯¯
@Injectable()
export class AuthService {
	constructor(
		@InjectRepository(User)
		private userRepo: EntityRepository<User>,
		private jwtService: JwtService
	) {}

	// æˆ–è€…æ›´ç³Ÿï¼šå±æ€§æ³¨å…¥
	@InjectRepository(User)
	private userRepo: EntityRepository<User>;
}
```

---

## æœåŠ¡å±‚æ¨¡å¼

### ä»“å‚¨æ¨¡å¼

ä½¿ç”¨ `@InjectRepository` è£…é¥°å™¨å’Œ `EntityRepository` ç±»å‹ã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
import { InjectRepository } from '@mikro-orm/nestjs';
import { EntityRepository } from '@mikro-orm/core';

@Injectable()
export class UserService {
	constructor(
		@InjectRepository(User)
		private readonly userRepo: EntityRepository<User>
	) {}
}

// âŒ é”™è¯¯ - æ‰‹åŠ¨æ³¨å…¥
@Injectable()
export class UserService {
	constructor(private em: EntityManager) {
		this.userRepo = em.getRepository(User);
	}
}
```

### EntityManager è®¿é—®

ä½¿ç”¨ç§æœ‰ getter è®¿é—® EntityManagerã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
@Injectable()
export class UserService {
	constructor(
		@InjectRepository(User)
		private readonly userRepo: EntityRepository<User>
	) {}

	private get em(): EntityManager {
		return this.userRepo.getEntityManager();
	}

	async create(data: CreateUserDto): Promise<User> {
		const user = this.userRepo.create(data);
		this.em.persist(user);
		await this.em.flush();
		return user;
	}
}

// âŒ é”™è¯¯
async create(data: CreateUserDto): Promise<User> {
	const user = this.userRepo.create(data);
	await this.em.persistAndFlush(user);
	return user;
}
```

---

## æ§åˆ¶å™¨å±‚æ¨¡å¼

### è£…é¥°å™¨é¡ºåº

æ§åˆ¶å™¨è£…é¥°å™¨åº”æŒ‰æ­¤é¡ºåºæ’åˆ—ï¼š

1. `@Controller()`
2. `@Get()`, `@Post()`, `@Put()`, `@Patch()`, `@Delete()`
3. `@Body()`, `@Param()`, `@Query()`, `@Headers()`, `@Req()`
4. `@HttpCode()`, `@Header()`

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
@Post('login')
async login(@Body() credentials: LoginDto): Promise<LoginResponse> {
	return this.authService.login(credentials);
}

@Post('register')
@HttpCode(HttpStatus.CREATED)
async register(@Body() credentials: RegisterDto): Promise<LoginResponse> {
	return this.authService.register(credentials);
}

// âŒ é”™è¯¯
@Post('login')
@Body()
async login(credentials: LoginDto): Promise<LoginResponse> {
	return this.authService.login(credentials);
}
```

### å“åº”æ ¼å¼

å§‹ç»ˆè¿”å›ç±»å‹åŒ–çš„å“åº”ã€‚

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - ä½¿ç”¨æ¥å£
export interface LoginResponse {
	accessToken: string;
	refreshToken: string;
	user: User;
}

@Post('login')
async login(@Body() credentials: LoginDto): Promise<LoginResponse> {
	return this.authService.login(credentials);
}

// âŒ é”™è¯¯ - æ— ç±»å‹
@Post('login')
async login(@Body() credentials: LoginDto) {
	return this.authService.login(credentials);
}
```

---

## å®ä½“å®šä¹‰

### å®ä½“ç»“æ„

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';
import { BaseEntity } from '@oksai/core';

@Entity()
export class User extends BaseEntity {
	@PrimaryKey()
	id: string = randomUUID();

	@Property({ unique: true, nullable: false })
	email!: string;

	@Property({ nullable: true })
	role?: UserRole;
}

// âŒ é”™è¯¯ - ç¼ºå°‘è£…é¥°å™¨
export class User {
	id: string;
	email: string;
	role: UserRole;
}
```

### å®ä½“å­—æ®µç±»å‹

ä½¿ç”¨æ­£ç¡®çš„ TypeScript ç±»å‹ï¼š

-   `string` - ç”¨äºæ–‡æœ¬
-   `number` - ç”¨äºæ•°å€¼
-   `boolean` - ç”¨äºæ ‡å¿—
-   `Date` - ç”¨äºæ—¶é—´æˆ³
-   `enum` - ç”¨äºæšä¸¾å€¼

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
@Property({ nullable: true })
	createdAt?: Date;

@Property({ nullable: true })
	isActive?: boolean;

// âŒ é”™è¯¯
@Property()
	createdAt: Date;

@Property()
	isActive: boolean;
```

---

## æ¨¡å—å®šä¹‰

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡®
import { Module } from '@nestjs/common';
import { MikroOrmModule } from '@mikro-orm/nestjs';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from './entities/user.entity';

@Module({
	imports: [MikroOrmModule.forFeature([User])],
	providers: [AuthService],
	controllers: [AuthController],
	exports: [AuthService]
})
export class AuthModule {}

// âŒ é”™è¯¯ - ç¼ºå°‘ exports
@Module({
	imports: [MikroOrmModule.forFeature([User])],
	providers: [AuthService],
	controllers: [AuthController]
})
export class AuthModule {}
```

---

## æµ‹è¯•è§„èŒƒ

### æµ‹è¯•æ–‡ä»¶ä½ç½®

-   å•å…ƒæµ‹è¯•ä¸è¢«æµ‹æ–‡ä»¶åŒç›®å½•ï¼Œå‘½åæ ¼å¼ `{filename}.spec.ts`
-   é›†æˆæµ‹è¯•æ”¾ç½®åœ¨ `tests/integration/`
-   ç«¯åˆ°ç«¯æµ‹è¯•æ”¾ç½®åœ¨ `tests/e2e/`

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

-   æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•è¦†ç›–ç‡é¡»è¾¾åˆ° 80% ä»¥ä¸Š
-   å…³é”®è·¯å¾„æµ‹è¯•è¦†ç›–ç‡é¡»è¾¾åˆ° 90% ä»¥ä¸Š
-   æ‰€æœ‰å…¬å…± API å¿…é¡»å…·å¤‡æµ‹è¯•ç”¨ä¾‹

### æµ‹è¯•æ–‡ä»¶ç¤ºä¾‹

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - user.service.spec.ts ä¸ user.service.ts åŒç›®å½•
import { Test, TestingModule } from '@nestjs/testing';
import { UserService } from './user.service';

describe('UserService', () => {
	let service: UserService;

	beforeEach(async () => {
		const module: TestingModule = await Test.createTestingModule({
			providers: [UserService]
		}).compile();

		service = module.get<UserService>(UserService);
	});

	it('should be defined', () => {
		expect(service).toBeDefined();
	});

	describe('create', () => {
		it('should create user with valid data', async () => {
			// æµ‹è¯•é€»è¾‘...
		});
	});
});
```

---

## æœ€ä½³å®è·µ

1. **å§‹ç»ˆå¯¹æ•°æ®åº“æ“ä½œä½¿ç”¨ async/await**
2. **ä½¿ç”¨ DTO è¿›è¡Œè¾“å…¥éªŒè¯**ï¼ˆé…åˆ class-validatorï¼‰
3. **å¯¹å¤šæ­¥éª¤æ“ä½œä½¿ç”¨äº‹åŠ¡**
4. **å¤„ç†è¾¹ç•Œæƒ…å†µ** - null æ£€æŸ¥ã€ç©ºæ•°ç»„ç­‰
5. **ä½¿ç”¨ NestJS Logger è®°å½•é‡è¦æ“ä½œ**ï¼Œæ—¥å¿—æ¶ˆæ¯ä½¿ç”¨ä¸­æ–‡
6. **ç»ä¸è®°å½•æ•æ„Ÿæ•°æ®** - å¯†ç ã€ä»¤ç‰Œç­‰
7. **ä½¿ç”¨ç¯å¢ƒå˜é‡è¿›è¡Œé…ç½®**
8. **ä¿æŒæ–¹æ³•ç®€æ´ä¸“æ³¨** - å•ä¸€èŒè´£
9. **ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡å** - é¿å…å•å­—æ¯ï¼ˆå¾ªç¯é™¤å¤–ï¼‰ï¼Œå¹¶æ·»åŠ ä¸­æ–‡æ³¨é‡Šè¯´æ˜ä¸šåŠ¡è¯­ä¹‰
10. **ä¸ºå…¬å…± API æ·»åŠ å®Œæ•´çš„ TSDoc æ³¨é‡Š**
11. **Git æäº¤ä¿¡æ¯ä½¿ç”¨è‹±æ–‡æè¿°**
12. **æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•è¦†ç›–ç‡è¾¾åˆ° 80% ä»¥ä¸Š**
13. **ä¼˜å…ˆé‡ç”¨ `@oksai` é¡¹ç›®çš„ä»£ç ï¼Œä¸è¦é‡å¤é€ è½®å­**

**ç¤ºä¾‹ï¼š**

```typescript
// âœ… æ­£ç¡® - æœ€ä½³å®è·µç¤ºä¾‹
@Injectable()
export class UserService {
	constructor(
		private readonly logger: Logger,
		@InjectRepository(User)
		private readonly userRepo: EntityRepository<User>
	) {}

	/**
	 * æ ¹æ®é‚®ç®±æŸ¥æ‰¾ç”¨æˆ·
	 *
	 * @param email - ç”¨æˆ·é‚®ç®±åœ°å€
	 * @returns ç”¨æˆ·ï¼ˆå¦‚æœæ‰¾åˆ°ï¼‰ï¼Œå¦åˆ™è¿”å› null
	 */
	async findByEmail(email: string): Promise<User | null> {
		this.logger.debug(`æ­£åœ¨æŸ¥æ‰¾é‚®ç®±ä¸º ${email} çš„ç”¨æˆ·`);
		return await this.userRepo.findOne({ email });
	}

	/**
	 * åˆ›å»ºæ–°ç”¨æˆ·
	 *
	 * @param userData - ç”¨æˆ·åˆ›å»ºæ•°æ®
	 * @returns å·²åˆ›å»ºçš„ç”¨æˆ·
	 * @throws BadRequestException å¦‚æœé‚®ç®±å·²å­˜åœ¨
	 */
	async create(userData: CreateUserDto): Promise<User> {
		const existing = await this.findByEmail(userData.email);
		if (existing) {
			this.logger.warn(`é‚®ç®±ä¸º ${userData.email} çš„ç”¨æˆ·å·²å­˜åœ¨`);
			throw new BadRequestException('æ­¤é‚®ç®±å·²è¢«ä½¿ç”¨');
		}

		const user = this.userRepo.create(userData);
		await this.em.persistAndFlush(user);
		this.logger.log(`å·²åˆ›å»ºæ–°ç”¨æˆ·ï¼š${user.id}`);
		return user;
	}
}

// âŒ é”™è¯¯
@Injectable()
export class UserService {
	constructor(@InjectRepository(User) private repo) {}

	async findByEmail(e) {
		return await this.repo.findOne({ e });
	}

	async create(data) {
		return await this.repo.create(data);
	}
}
```

---

## ç‰ˆæœ¬ä¿¡æ¯

-   **æ–‡æ¡£ç‰ˆæœ¬ï¼š** 1.0.0
-   **æœ€åæ›´æ–°ï¼š** 2026-02-04
-   **ç»´æŠ¤è€…ï¼š** OKSAI å¹³å°å›¢é˜Ÿ
